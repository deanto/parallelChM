#include <math.h>
#include <fstream>
#include "timer.h"

using namespace std;

// Линейный конгруэнтный генератор
int x;

int a=845,c=2625,m=8192; // из презентации значения
// int a=845,c=2625,m=1024;

int GET_rund ()
{
	x=(a*x+c)%m;  // даст число от 0 до m=8192
	return x;
}

void SET_x0_rund (int x0)
{
	x=x0;
}

double rundforBoxMuller()
{
	// выдает равномерно распределенную случайную величину на отрезке [-1,1]
	double v1=GET_rund(); // получили от 0 до m
	double t;
	double r;

	 t=v1/m*2;// теперь от 0 до 2
	 r=t-1; // теперь от -1 до 1

	 
	 // t= ((double)(GET_rund()/m)-0,5);

	  return r;
}
// _______________________________Линейный конгруэнтный генератор



// Функция плотности для нормального распределения
double NormalDensity(double x,double mu,double sigquad)
{
	double t= (  1/(sqrt(sigquad)*sqrt(2*3.141592653589793238462))  )  *exp((-1)*(((x-mu)*(x-mu))/(2*sigquad)));

	// принимаем два параметра распределения и точку x
	return t;
}

// площадь кривой на интервале [a,b] со значениями функции Fa, Fb соответственно
double Square(double a,double b,double Fa, double Fb)
{
	double t= (Fa+Fb)*(b-a)/2;
	return t;
}




// Функция стандартного нормального распределения

double data[] = {
	0.5000, 0.5040, 0.5080, 0.5120, 0.5160, 0.5199, 0.5239, 0.5279, 0.5319, 0.5359,
	0.5398, 0.5438, 0.5478, 0.5517, 0.5557, 0.5596, 0.5636, 0.5675, 0.5714, 0.5753,
	0.5793, 0.5832, 0.5871, 0.5910, 0.5948, 0.5987, 0.6026, 0.6064, 0.6103, 0.6141,
	0.6179, 0.6217, 0.6255, 0.6293, 0.6331, 0.6368, 0.6406, 0.6443, 0.6480, 0.6517,
	0.6554, 0.6591, 0.6628, 0.6664, 0.6700, 0.6736, 0.6772, 0.6808, 0.6844, 0.6879,
	0.6915, 0.6950, 0.6985, 0.7019, 0.7054, 0.7088, 0.7123, 0.7157, 0.7190, 0.7224,
	0.7257, 0.7291, 0.7324, 0.7357, 0.7389, 0.7422, 0.7454, 0.7486, 0.7517, 0.7549,
	0.7580, 0.7611, 0.7642, 0.7673, 0.7704, 0.7734, 0.7764, 0.7794, 0.7823, 0.7852,
	0.7881, 0.7910, 0.7939, 0.7967, 0.7995, 0.8023, 0.8051, 0.8078, 0.8106, 0.8133,
	0.8159, 0.8186, 0.8212, 0.8238, 0.8264, 0.8289, 0.8315, 0.8340, 0.8365, 0.8389,
	0.8413, 0.8438, 0.8461, 0.8485, 0.8508, 0.8531, 0.8554, 0.8577, 0.8599, 0.8621,
	0.8643, 0.8665, 0.8686, 0.8708, 0.8729, 0.8749, 0.8770, 0.8790, 0.8810, 0.8830,
	0.8849, 0.8869, 0.8888, 0.8907, 0.8925, 0.8944, 0.8962, 0.8980, 0.8997, 0.9015,
	0.9032, 0.9049, 0.9066, 0.9082, 0.9099, 0.9115, 0.9131, 0.9147, 0.9162, 0.9177,
	0.9192, 0.9207, 0.9222, 0.9236, 0.9251, 0.9265, 0.9279, 0.9292, 0.9306, 0.9319,
	0.9332, 0.9345, 0.9357, 0.9370, 0.9382, 0.9394, 0.9406, 0.9418, 0.9429, 0.9441,
	0.9452, 0.9463, 0.9474, 0.9484, 0.9495, 0.9505, 0.9515, 0.9525, 0.9535, 0.9545,
	0.9554, 0.9564, 0.9573, 0.9582, 0.9591, 0.9599, 0.9608, 0.9616, 0.9625, 0.9633,
	0.9641, 0.9649, 0.9656, 0.9664, 0.9671, 0.9678, 0.9686, 0.9693, 0.9699, 0.9706,
	0.9713, 0.9719, 0.9726, 0.9732, 0.9738, 0.9744, 0.9750, 0.9756, 0.9761, 0.9767,
	0.9772, 0.9778, 0.9783, 0.9788, 0.9793, 0.9798, 0.9803, 0.9808, 0.9812, 0.9817,
	0.9821, 0.9826, 0.9830, 0.9834, 0.9838, 0.9842, 0.9846, 0.9850, 0.9854, 0.9857,
	0.9861, 0.9864, 0.9868, 0.9871, 0.9875, 0.9878, 0.9881, 0.9884, 0.9887, 0.9890,
	0.9893, 0.9896, 0.9898, 0.9901, 0.9904, 0.9906, 0.9909, 0.9911, 0.9913, 0.9916,
	0.9918, 0.9920, 0.9922, 0.9925, 0.9927, 0.9929, 0.9931, 0.9932, 0.9934, 0.9936,
	0.9938, 0.9940, 0.9941, 0.9943, 0.9945, 0.9946, 0.9948, 0.9949, 0.9951, 0.9952,
	0.9953, 0.9955, 0.9956, 0.9957, 0.9959, 0.9960, 0.9961, 0.9962, 0.9963, 0.9964,
	0.9965, 0.9966, 0.9967, 0.9968, 0.9969, 0.9970, 0.9971, 0.9972, 0.9973, 0.9974,
	0.9974, 0.9975, 0.9976, 0.9977, 0.9977, 0.9978, 0.9979, 0.9979, 0.9980, 0.9981,
	0.9981, 0.9982, 0.9982, 0.9983, 0.9984, 0.9984, 0.9985, 0.9985, 0.9986, 0.9986,
	0.9987, 0.9987, 0.9987, 0.9988, 0.9988, 0.9989, 0.9989, 0.9989, 0.9990, 0.9990,
	0.9990, 0.9991, 0.9991, 0.9991, 0.9992, 0.9992, 0.9992, 0.9992, 0.9993, 0.9993,
	0.9993, 0.9993, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9995, 0.9995, 0.9995,
	0.9995, 0.9995, 0.9995, 0.9996, 0.9996, 0.9996, 0.9996, 0.9996, 0.9996, 0.9997,
	0.9997, 0.9997, 0.9997, 0.9997, 0.9997, 0.9997, 0.9997, 0.9997, 0.9997, 0.9998,
	0.9998, 0.9998, 0.9998, 0.9998, 0.9998, 0.9998, 0.9998, 0.9998, 0.9998, 0.9998,
	0.9998, 0.9998, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
	0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
	0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
	1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000};


	// стандартное нормальное распределение в интервале 0 - 4
double StandartRaspr(double x)
{


	// x от 0 до 4
	// шаг 0,01 в таблице
	double result;
	bool flag = false;
	if (x<0){x*=(-1.0); flag=true;} // значит нужны меры

	int a,b;
	a=x/0.1; // номер строки
	b=x/0.01-10*a; // номер столбца

	// a,b - это значение слева (одно и тоже для 0.811 0.812 0.813 ... 0.819. значение для 0.81)
	
	double ostatok=(x-a*0.1-b*0.01);
	
	if (ostatok>0.000001) 

	{
		double l,r;
		l=data[a*10+b];
		r=data[a*10+b+1];// значения в левой и правой ближних точках сетки

		double y,z; // ближайшие значения для х
		y=a*0.1+b*0.01;
		z=y+0.01;


		double c=(x-y)/(z-y);
		result = (1-c)*l+c*r;
		
	} else result = data[a*10+b];
		
	if (!flag) return result; else return 1-result;
	
}

    // нормальное распределение с параметрами mu, sigquad для х
double NormRaspr(double x,double mu, double sigquad)
{
	return StandartRaspr((x-mu)/sqrt(sigquad));
}



// быстрая сортировочка из интернета
void qs(double *items, int left, int right)
{
  register int i, j;
  double x, y;
 
  i = left; j = right;
  x = items[(left+right)/2];
 
  do {
    while((items[i] < x) && (i < right)) i++;
    while((x < items[j]) && (j > left)) j--;
 
    if(i <= j) {
      y = items[i];
      items[i] = items[j];
      items[j] = y;
      i++; j--;
    }
  } while(i <= j);
 
  if(left < j) qs(items, left, j);
  if(i < right) qs(items, i, right);
}

void quickSort(double *items, int count)
{
  qs(items, 0, count-1);
}





int main(int argc, char* argv[])
{
	
	if(argc != 4)
	{
		printf("wrong input format (program inputfile outputfile timefile)");
		getchar();
		return -1;
	}
	

	// чтение из файла

	int count;
	double mu, sigquad; //количество чисел, мю, сигма в квадрате
	
	ifstream F;
	F.open(argv[1],ios::in);
	F>>count>>mu>>sigquad;
	F.close();
	
	// ________________чтение из файла


	Timer timer;
	timer.reset();
    timer.start();

// используем  Преобразование Бокса — Мюллера

			
	


	double *sequence = new double[count+1];// создали массив

	double x,y,s,BM;

	SET_x0_rund(0);

	int i=0;
	while (i<count)
	{
		do 
		{
			x=rundforBoxMuller();
			y=rundforBoxMuller();
			s=x*x+y*y;
		} while (s >= 1 || s == 0);

		
		BM= sqrt(-2.0 * log(s) / s);

		sequence[i]=x*BM*sqrt(sigquad)+mu;
		sequence[i+1]=y*BM*sqrt(sigquad)+mu;

		i+=1;
	}

	timer.stop();
	double time_result = timer.getElapsed();


	double * savedseq = new double[count];
	for(int i=0;i<count;i++) savedseq[i]=sequence[i];

// посчитали время работы


	// теперь критерии
// Пирсон

	double a=mu-3*sqrt(sigquad);
	double b=mu+3*sqrt(sigquad);
	// это интервал.
	
	int N = 11;
	// поделим его на 11 частей

	double* frequency = new double[N];
	for(int i = 0; i < N; i++) frequency[i] = 0;
	// сюда будем записывать, сколько в интервале полученных значений
	
	double interval = (b - a) / (double)N;
	// ширина интервала

	double at,bt;

	for(int i = 0; i < count; i++)
	{// пройдем по всем сгенерированным числам
		int j=0;
		bool flag=true;

		while (flag)
		{
			at=a+j*interval;
			bt=a+(j+1)*interval;

			if ((at<=sequence[i])&&(bt>sequence[i])) 
				frequency[j]++;
			j++; if (j==N) flag=false;
		}

	}

	// посчитали  сколько чисел попало в каждый интервал(записано в frequency[i])
	// теперь превратим эти числа в вероятности( в новый массив запишем)

	double* frequencyP=new double[N];

	for (int i=0;i<N;i++) 
		frequencyP[i]=frequency[i]/count;

	// теперь возьмем функцию плотности и посчитаем, какова реальная вероятность попасть в каждый интервал (площадь под графиком)
	double* NormalFrequencyP = new double[N];


	for (int i=0;i<N;i++)
	{

		NormalFrequencyP[i]=Square(a+i*interval,a+(i+1)*interval,NormalDensity(a+i*interval,mu,sigquad),NormalDensity(a+(i+1)*interval,mu,sigquad));
	}

	
	// проверка что вероятности в сумме даеют 1
	/*double p=0;
	for (int i=0;i<N;i++) p+=frequencyP[i];
	p=0;
	for (int i=0;i<N;i++) p+=NormalFrequency[i];*/

	
	// имеем теоретические вероятности и практические
	// посчитаем критерий пирсона 

	double xi = 0;

	for (int i=0;i<N;i++) 
		xi+=((NormalFrequencyP[i]-frequencyP[i])*(NormalFrequencyP[i]-frequencyP[i]))/frequencyP[i];
	xi*=N;

	
	// пирсона посчитали

	

// колмагоров
	
	// нужно упорядочить по возрастанию значения полученные генератором.
	quickSort(sequence,count);
	
	// теперь нужно пройти и посчитать "ступеньки" функции распределения нашей, по этим значениям
	// пойдем по всем значениям. как только встретили больше чем было до этого - это новая ступенька.
	// берем следующее большее значение
	// знаем сколько было сгенерировано чисел меньше этого. - это и есть значение функции распределения для этого числа
	// 

	int sum;// сюда комулятивно записываем сколько было значений до этого
	double cur;// это текущее значение. так мы поймем когда ступенька случится

	sum=1;
	cur=sequence[0];

	double max=0;// сюда будем записывать максимальное расхождение теоретической функции распределения от нашей
	
	for (int i=1;i<count;i++)
	{
		if (sequence[i]==cur)
		{
			// значит мы на то-же ступеньке
			sum++;
		} else
		{
			cur=sequence[i];
			// значит переходим на следующую ступеньку
			// sum означает сколько было значений до этого текущего, sum/count - вероятность встретить значения меньше чем текущее
	
			double tmp = abs( NormRaspr(cur,mu,sigquad) - (double)sum/(double)count );
			if (tmp>max) max=tmp;

			sum++;
		}
	}


	double colmagorov=max*sqrt((double)count);

	//колмагорова посчитали 

	

	/// запишем файлики и все

	ofstream T;
	T.open(argv[2]);
	T << xi << endl << colmagorov << endl;
	for(int i = 0; i < count; i++) T << savedseq[i] << endl;
	T.close();

	ofstream O;	
	O.open(argv[3]);
	O << time_result;
	O.close();

	delete[] sequence;
	delete[] savedseq;
	return 0;
}

